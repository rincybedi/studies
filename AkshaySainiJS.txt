A global execution conrtext is created for each js cpde into 2 phases:
	1 memory   Phase - goes line by line n allocate memory for varuiables(undefined) and fucntions (whole body of fucn) - just like key val pair
	2  code execution phas - goes line by line(synchr) and initializes variables(i:2)	

	when js engine encouter a fun call, it create another execn context inside global context n push this newly created context inside call stack

	Hoisting: 
	even before the forst lien is exec, js has covered phase1 , so hoitsong
	see what Global holds for methods and Global.window holds for variables in console

	Reference error// for var when not decalred, no memory allocation iowth this key

	eg
	getName(); //getName
	getName1(); //typo error getName1 is not a fun

	getName(){ // a function in Global context
		log("getName");
	}	

	var getName1() => {  // a variable in Global
		log("getName1");
	}	